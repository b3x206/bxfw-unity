#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;

using System;
using System.Text;
using System.IO;
using System.Collections;
using System.Collections.Generic;

#if UNITY_EDITOR
/// <summary>
/// Enum generator. Only meant for use in editor.
/// </summary>
public static class EnumGenerator
{
    public static readonly string DefaultCreationPath = $"{Directory.GetCurrentDirectory()}/Assets/Scripts";
    
    /// <summary>
    /// Non-async file generator. Might cause crashes on bigger files.
    /// </summary>
    /// <param name="enums"></param>
    /// <returns></returns>
    public static FileInfo GenerateFile(string enumclass_name, string[] enumclass_args = null, bool ReloadAssets = true, DirectoryInfo directory = null)
    {        
        StringBuilder FileText = new StringBuilder();

        FileText.Append("// Autogenerated by EnumGenerator.\n");
        FileText.Append($"public enum {enumclass_name}\n");
        FileText.Append("{\n");
        if (enumclass_args == null)
        {
            /* Debug.LogWarning("You are about to generate a blank enum."); */
            FileText.Append("\n}");
            goto _DirSave;
        }

        /* Create the file contents */
        for (uint i = 0; i < enumclass_args.Length; i++)
        { enumclass_args[i] = enumclass_args[i].Replace(' ', '_'); }

        for (uint i = 0; i < enumclass_args.Length; i++)
        {
            /* 4 spaces behind the args. */
            FileText.Append($"    {enumclass_args[i]} = {i}{(i == enumclass_args.Length - 1 ? ' ' : ',')}\n");
        }
        FileText.Append("}");

        _DirSave:
        FileInfo inf;

        if (directory == null)
        {
            /* Directory.GetCurrentDirectory() always returns visual studio project directory. */
            
            if (!Directory.Exists(DefaultCreationPath))
            {
                Debug.LogWarning($"Created a default directory for generated enum in : {DefaultCreationPath} | The file will look like : {DefaultCreationPath}/{enumclass_name}.cs");
                Directory.CreateDirectory(DefaultCreationPath);
            }

            using (var fs = File.Create($"{DefaultCreationPath}/{enumclass_name}.cs"))
            {
                string FTextString = FileText.ToString();
                fs.Write(Encoding.UTF8.GetBytes(FTextString), 0, Encoding.UTF8.GetByteCount(FTextString));
                inf = new FileInfo(fs.Name);
            }
        }
        else
        {
            if (!directory.Exists)
            {
                Debug.LogWarning($"Created a default directory for generated enum in : {directory.FullName}");
                directory.Create();
            }

            /* Delete file anyways if the same thing exists. */
            if (File.Exists($"{directory.FullName}/{enumclass_name}.cs"))
            { File.Delete($"{directory.FullName}/{enumclass_name}.cs"); }

            using (var fs = File.Create($"{directory.FullName}/{enumclass_name}.cs"))
            {
                string FTextString = FileText.ToString();

                fs.Write(Encoding.UTF8.GetBytes(FTextString), 0, Encoding.UTF8.GetByteCount(FTextString));
                inf = new FileInfo(fs.Name);
            }
        }

        if (ReloadAssets)
        { AssetDatabase.Refresh(); }

        return inf;
    }
    /* Non-functional. */
    public static void AddToEnumFile()
    {
        Debug.Log("Doesn't work.");
    }
}
#endif

/* Maybe the light probes?
[Serializable]
public class SphericalHarmonics
{
    public float[] Coefficients = new float[27];
}
*/

[Serializable]
public class LightmapScenarioData
{
    public string name;
    public Texture2D[] LightmapCompDir;
    public Texture2D[] LightmapCompLight;
    public Texture2D[] LightmapCompShadow;
    public Texture2D[] LightProbes;
    public LightmapsMode LightmapMode;

    public static void ApplyToLightmapOptions(LightmapScenarioData data)
    {
        int Length = LightmapSettings.lightmaps.Length;

        /* all you need is a list. (and not an array, please do not change it to an array) */
        List<LightmapData> LightMapDatArray = new List<LightmapData>();

        for (int i = 0; i < Length; i++)
        { LightMapDatArray.Add(new LightmapData { lightmapDir = data.LightmapCompDir[i], lightmapColor = data.LightmapCompLight[i], shadowMask = data.LightmapCompShadow[i] }); }

        LightmapSettings.lightmaps = LightMapDatArray.ToArray();

#if UNITY_EDITOR
        Debug.LogWarning("[ChangeLightmap] Applied lightmap options.");
        /* Completely Debug 
        for (int i = 0; i < Length; i++)
        { Debug.Log($"[ChangeLightmap] (Debug) More info about the current LightmapSettings (names) : {LightmapSettings.lightmaps[i].lightmapDir.name} | {LightmapSettings.lightmaps[i].shadowMask.name} | {LightmapSettings.lightmaps[i].lightmapColor.name} "); } */
#endif

        /* TODO : Change light probe assets if we can find where tf it is stored. */
    }
}

public class ChangeLightmap : MonoBehaviour
{
    public string LightmapName;

    public LightmapEnum DefaultLightmap;
    public bool SetDefaultLightmapOnAwake;

    /* Const & Hidden variables */
    private static readonly string ResFile = $"{Directory.GetCurrentDirectory()}\\Assets\\Resources\\SavedLightmaps";
    public const string EnumName = "LightmapEnum";

    [HideInInspector] public List<LightmapScenarioData> LInfos = new List<LightmapScenarioData>();

    /* Runtime Methods. */
    private void Awake()
    {
        if (SetDefaultLightmapOnAwake && Enum.GetValues(typeof(LightmapEnum)).Length != 0)
        { SetLightmap(DefaultLightmap); }
    }

    public void SetLightmap(LightmapEnum option)
    {  LightmapScenarioData.ApplyToLightmapOptions(LInfos[(int)option]); }

    /* Failed attempt at fading lMaps
     * Use a material and gather the textures for lightmap from there. In fact we can use a fully material based LightmapStorage
     * as we are just using c# (which is bad, use shaders instead).
    public void MakeFadeableLightmap(LightmapEnum to, float FadeSpeed, LightmapEnum from = (LightmapEnum)int.MinValue)
    {
        /* IgnoreFrom = Ignored if we want to not use a from value and use the current lightmap instead 
        // bool IgnoreFrom = (int)from == int.MinValue;

        /* Create faded lightmap textures. (we can bake or instance the textures) 
        StartCoroutine(CreateFadeImageRuntime((int)to, (int)from, FadeSpeed));

    }
    private IEnumerator CreateFadeImageRuntime(int To, int From, float FadeSpeed)
    {
        int Length = LightmapSettings.lightmaps.Length;

        LightmapData[][] dataFromto = new LightmapData[Length][];
        
        try
        {
            /* Gethering values 
            for (int i = 0; i < Length; i++)
            {
                dataFromto[i][0] = new LightmapData 
                { 
                    lightmapDir = LInfos[To].LightmapCompDir[i],
                    lightmapColor = LInfos[To].LightmapCompLight[i],
                    shadowMask = LInfos[To].LightmapCompShadow[i] 
                };
                dataFromto[i][1] = From != int.MinValue ? new LightmapData
                {
                    lightmapDir = LInfos[From].LightmapCompDir[i],
                    lightmapColor = LInfos[From].LightmapCompLight[i],
                    shadowMask = LInfos[From].LightmapCompShadow[i]
                }
                : LightmapSettings.lightmaps[i];
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"An exception occured while getting the lightmaps. Error Details\n{e.Message}\n{e.StackTrace}");
            yield break;
        }
        yield return null;

        /* Start a float fading. 
        CTween.To(() => { return secSubCoroutine[0]; }, (float f) => { secSubCoroutine[0] = f; }, 0f, FadeSpeed);
        CTween.To(() => { return secSubCoroutine[1]; }, (float f) => { secSubCoroutine[1] = f; }, 1f, FadeSpeed);

        /* Faded graphics 
        for (int i = 0; i < Length; i++)
        {
            for (int j = 0; j < dataFromto[i][0].lightmapColor.width * dataFromto[i][0].lightmapColor.height; j++)
            {
                /* It would be better if we made this on a material then get the shaders but idk. 
                 * In fact we have to enumerate through w * h amount of pixels. ok
                dataFromto[i][0].lightmapColor.SetPixels32
                    (0, 0, dataFromto[i][0].lightmapColor.width, dataFromto[i][0].lightmapColor.height,
                    new[] { new Color32(255, 255, 255, (byte)Mathf.Lerp(255, 0, secSubCoroutine[0])) });
                dataFromto[i][0].lightmapColor.SetPixels32
                    (0, 0, dataFromto[i][0].lightmapColor.width, dataFromto[i][0].lightmapColor.height,
                    new[] { new Color32(255, 255, 255, (byte)Mathf.Lerp(255, 0, secSubCoroutine[0])) });
                dataFromto[i][0].lightmapColor.SetPixels32
                    (0, 0, dataFromto[i][0].lightmapColor.width, dataFromto[i][0].lightmapColor.height,
                    new[] { new Color32(255, 255, 255, (byte)Mathf.Lerp(255, 0, secSubCoroutine[0])) });
            }
        }
    }
    /// <summary>
    /// Fade array for texture fading.
    /// 0 : Starts from 1
    /// 1 : Starts from 0
    /// </summary>
    private float[] secSubCoroutine = { 1f, 0f };
    */

    #region Unity Editor
#if UNITY_EDITOR

    #region Baking & Generation
    public LightmapScenarioData GenerateLightmapInfoFromDirectory(DirectoryInfo Dir)
    {
        /* Setup for files */
        var LightmapTexDir = new List<Texture2D>();
        var LightmapTexLight = new List<Texture2D>();
        var LightmapTexShadow = new List<Texture2D>();
        var ReflectProbe = new List<Texture2D>();
        var LmapMode = LightmapSettings.lightmapsMode;

        Debug.Log($"Started generation | Directory path : {Dir.FullName}, GetFiles result {Dir.GetFiles("*", SearchOption.AllDirectories).Length}");

        foreach (FileInfo FInf in Dir.GetFiles("*", SearchOption.AllDirectories))
        {
            bool[] FileExtBool = new bool[] { FInf.Extension == "*.png", FInf.Extension == "*.exr" };
            
            if (!FileExtBool[0] && !FileExtBool[1]) { continue; } 
            
            string[] FInfSplitPath = FInf.FullName.Split('\\');
            /* 3 directories down for resources path for the file without the extension. */
            string ResPath = $"{FInfSplitPath[FInfSplitPath.Length - 3]}\\{FInfSplitPath[FInfSplitPath.Length - 2]}\\{FInfSplitPath[FInfSplitPath.Length - 1]}".Split('.')[0];
            

            /* Unity Generated Lightmap File Name Structure                     *
             * Lightmap Computed Dir : Lightmap-0_comp_dir.png                  *
             * Lightmap Computed Light : Lightmap-0_comp_light.exr              *
             * Lightmap Computed Shadowmask : Lightmap-0_comp_shadowmask.png    *
             * Lightmap Reflection Probe : ReflectionProbe-0.exr                */

            /* .png Extension file */
            if (FileExtBool[0])
            {
                if (FInf.Name.Contains("comp_dir"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains comp_dir.\nFile Info : {FInf.Name}");
                    LightmapTexDir.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }

                if (FInf.Name.Contains("comp_shadowmask"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains comp_shadowmask.\nFile Info : {FInf.Name}");
                    LightmapTexShadow.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }
            }

            /* .exr Extension file */
            if (FileExtBool[1])
            {
                if (FInf.Name.Contains("comp_light"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains comp_light.\nFile Info : {FInf.Name}");
                    LightmapTexLight.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }

                if (FInf.Name.Contains("ReflectionProbe"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains reflectionprobe.\nFile Info : {FInf.Name}");
                    ReflectProbe.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }
            }
        }

        var sData = new LightmapScenarioData
        {
            name = LightmapName,
            LightmapCompDir = LightmapTexDir.ToArray(),
            LightmapCompLight = LightmapTexLight.ToArray(),
            LightmapCompShadow = LightmapTexShadow.ToArray(),
            LightProbes = ReflectProbe.ToArray(),
            LightmapMode = LmapMode
        };

        //LightmapInfos.Add(sData);
        // GenerateJSONSaveFolder(sData, $"{Dir.FullName}\\{JsonFileName}");

        Debug.Log("[ChangeLightmap] Succesfully generated LightmapScenarioData.");

        return sData;
    }

    public void ClearData(bool deletefolder)
    {
        if (deletefolder)
        {
            Directory.Delete(ResFile);
            File.Delete($"{ResFile}.meta");
            LInfos.Clear();
            EnumGenerator.GenerateFile(EnumName);
        }
        else
        {
            LInfos.Clear();
            EnumGenerator.GenerateFile(EnumName);
        }
    }

    public void BakeLightmapInstance(Action optionalEndActionToAdd = null)
    {
        if (Application.isPlaying)
        {
            Debug.LogWarning("[ChangeLightmap] You cannot bake lights while in play mode!");
            return;
        }

        /* Cast the enum values into strings
         * We store the Enum names in (you guessed it) the Enum itself. */
        var EnumArr = Enum.GetValues(typeof(LightmapEnum));
        List<string> DataAssetNames = new List<string>();

        if (EnumArr.Length != 0)
        {
            for (int i = 0; i < EnumArr.Length; i++)
            { DataAssetNames.Add(((LightmapEnum)EnumArr.GetValue(i)).ToString()); }
        }

        DataAssetNames.Add(LightmapName);

        /* Start baking. */
        if (Lightmapping.BakeAsync())
        {
            Debug.LogWarning("[ChangeLightmap] Bake with copy has started...");

            /* Questions about the Lightmapping.bakeCompleted event delegate *
             * 1 : How tf you add the same event over and over?              *
             * 1A : It cleans itself. (only we can hope it does that)        *
             * 2 : What happens when the bake is postponed or cancelled?     *
             * 2A : It doesn't execute.                                      *
             * thank for not asking -> me looking for who asked              */

            Lightmapping.bakeCompleted += delegate
            {
                /* Find the Lightmapping directory, then put it into resources
                 * We can use the lightmapper file from resources. */
                try
                {
                    DirectoryCopy(GetLightmapperDirectory().FullName, $"{ResFile}\\{LightmapName}", true);

                    /* Lighting datas are always named like that. */
                    LInfos.Add(GenerateLightmapInfoFromDirectory(new DirectoryInfo($"{ResFile}\\{LightmapName}")));
                }
                catch (Exception e)
                {
                    Debug.LogError($"[ChangeLightmap] An exception occured while loading resource.\nException : {e.Message}\nStacktrace : {e.StackTrace}");

                    return;
                }

                EnumGenerator.GenerateFile(EnumName, DataAssetNames.ToArray());
            };

            if (optionalEndActionToAdd != null)
            { Lightmapping.bakeCompleted += optionalEndActionToAdd; }
        }
    }
    /// <summary>
    /// Adds directory to the baked assets list.
    /// The name of the lightmap the same as the directory name.
    /// </summary>
    /// <param name="inf"></param>
    public void AddToBakedList(DirectoryInfo inf, bool UseUserdefStr)
    {
        /* Find the Lightmapping directory, then put it into resources
         * We can use the lightmapper file from resources. */
        if (Application.isPlaying)
        {
            Debug.LogWarning("[ChangeLightmap] You cannot load baked lights while in play mode! (i mean it's possible but i don't recommend)");
            return;
        }

        /* Cast the enum values into strings
         * We store the Enum names in (you guessed it) the Enum itself. */
        var EnumArr = Enum.GetValues(typeof(LightmapEnum));
        List<string> DataAssetNames = new List<string>();

        if (EnumArr.Length != 0)
        {
            for (int i = 0; i < EnumArr.Length; i++)
            { DataAssetNames.Add(((LightmapEnum)EnumArr.GetValue(i)).ToString()); }
        }

        DataAssetNames.Add(UseUserdefStr ? LightmapName : inf.Name);

        /* DirectoryInfo copiedLightmap = new DirectoryInfo(GetLightmapperDirectory().FullName); */
        DirectoryCopy(inf.FullName, $"{ResFile}\\{(UseUserdefStr ? LightmapName : inf.Name)}", true);

        try
        {
            /* Add the generated info to array.
             * oh god why do i use stupid string consts, i need to clean this. but it works B) */
            LInfos.Add(GenerateLightmapInfoFromDirectory(new DirectoryInfo($"{ResFile}\\{(UseUserdefStr ? LightmapName : inf.Name)}")));
        }
        catch (Exception e)
        {
            Debug.LogError($"[ChangeLightmap] An exception occured while loading resource.\nException : {e.Message}\nStacktrace : {e.StackTrace}");
            return;
        }

        EnumGenerator.GenerateFile(EnumName, DataAssetNames.ToArray());
    }
    #endregion

    #region Directory Actions
    /* Stolen from microsoft docs but it was gonna be stolen anyway */
    /// <summary>
    /// Copies the directory a into the b point
    /// </summary>
    /// <param name="sourceDirName"></param>
    /// <param name="destDirName"></param>
    /// <param name="copySubDirs"></param>
    public static void DirectoryCopy(string sourceDirName, string destDirName, bool copySubDirs)
    {
        // Get the subdirectories for the specified directory.
        DirectoryInfo dir = new DirectoryInfo(sourceDirName);

        if (!dir.Exists)
        {
            throw new DirectoryNotFoundException
                ($"Source directory does not exist or could not be found: {sourceDirName}");
        }

        if (sourceDirName.Equals(destDirName))
        {
            Debug.LogWarning("[ChangeLightmap] The directory you are trying to copy is the same as the destination directory.");
            return;
        }

        DirectoryInfo[] dirs = dir.GetDirectories();

        // If the destination directory doesn't exist, create it.       
        Directory.CreateDirectory(destDirName);

        // Get the files in the directory and copy them to the new location.
        FileInfo[] files = dir.GetFiles();
        foreach (FileInfo file in files)
        {
            string tempPath = Path.Combine(destDirName, file.Name);
            file.CopyTo(tempPath, false);
        }

        // If copying subdirectories, copy them and their contents to new location.
        if (copySubDirs)
        {
            foreach (DirectoryInfo subdir in dirs)
            {
                string tempPath = Path.Combine(destDirName, subdir.Name);
                DirectoryCopy(subdir.FullName, tempPath, copySubDirs);
            }
        }
    }

    /* oh no this is terrible. */
    #region Lightmapper Directory
    /// <summary>
    /// Gets the current lightmapper directory for current scene.
    /// </summary>
    /// <returns></returns>
    public static DirectoryInfo GetLightmapperDirectory()
    {
        string[] unityFiles = Directory.GetFiles($"{Directory.GetCurrentDirectory()}\\Assets", "*.unity", SearchOption.AllDirectories);

        string currSceneName = SceneManager.GetActiveScene().name;

        foreach (string s in unityFiles)
        {
            string[] split = s.Split('\\');

            /* welcome to mess
             * you don't need regex, you have a hakkerman */
            if (split[split.Length - 1].Split('.')[0].Equals(currSceneName))
            {
                /* Found the scene directory, 
                 * find the directory nearby the Scene file and copy that to your destination. */
                return new DirectoryInfo(s.Split('.')[0]);
            }
        }

        Debug.LogError("Could not find any lightmapper directory.");
        return null;
    }
    /// <summary>
    /// Gets the current lightmapper directory for the written scene name.
    /// </summary>
    /// <param name="SceneName"></param>
    /// <returns></returns>
    public static DirectoryInfo GetLightmapperDirectory(string SceneName)
    {
        string[] unityFiles = Directory.GetFiles($"{Directory.GetCurrentDirectory()}\\Assets", "*.unity", SearchOption.AllDirectories);

        string SceneNameMatched = null;

        for (int i = 0; i < SceneManager.sceneCount; i++)
        {
            string s = SceneManager.GetSceneAt(i).name;
            if (SceneName.Equals(s))
            {
                SceneNameMatched = s;
                break;
            }
        }

        if (string.IsNullOrEmpty(SceneNameMatched))
        {
            Debug.LogError($"No scene with name {SceneName} exists.");
            return null;
        }

        foreach (string s in unityFiles)
        {
            string[] split = s.Split('\\');

            /* welcome to mess
             * you don't need regex, you have a hakkerman */
            if (split[split.Length - 1].Split('.')[0].Equals(SceneNameMatched))
            {
                /* Found the scene directory, 
                 * find the directory nearby the Scene file and copy that to your destination. */
                return new DirectoryInfo(s.Split('.')[0]);
            }
        }

        Debug.LogError("Could not find any lightmapper directory.");
        return null;
    }
    public static DirectoryInfo GetLightmapperDirectory(int SceneIndex)
    {
        string[] unityFiles = Directory.GetFiles($"{Directory.GetCurrentDirectory()}\\Assets", "*.unity", SearchOption.AllDirectories);

        string SceneNameToMatch = SceneManager.GetSceneAt(SceneIndex).name;

        if (string.IsNullOrEmpty(SceneNameToMatch))
        {
            Debug.LogError($"No scene with index {SceneIndex} exists.");
            return null;
        }

        foreach (string s in unityFiles)
        {
            string[] split = s.Split('\\');

            /* welcome to mess
             * you don't need regex, you have a hakkerman */
            if (split[split.Length - 1].Split('.')[0].Equals(SceneNameToMatch))
            {
                /* Found the scene directory, 
                 * find the directory nearby the Scene file and copy that to your destination. */
                return new DirectoryInfo(s.Split('.')[0]);
            }
        }

        Debug.LogError("Could not find any lightmapper directory.");
        return null;
    }
    #endregion

    #endregion

#endif
    #endregion
}
