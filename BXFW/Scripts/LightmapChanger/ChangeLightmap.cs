#if UNITY_EDITOR
using UnityEditor;
using BXFW.Editor;
#endif

using UnityEngine;
using UnityEngine.SceneManagement;

using BXFW;

using System;
using System.Text;
using System.IO;
using System.Collections.Generic;

#if UNITY_EDITOR
namespace BXFW.Editor
{
    /// <summary>
    /// Enum generator. Only meant for use in editor.
    /// </summary>
    public static class EnumGenerator
    {
        /// <summary>
        /// User defined creation path.
        /// <br>This is stored as another value for appending it with <see cref="Directory.GetCurrentDirectory"/>.</br>
        /// </summary>
        public static string CreationPathUserDefined = "/Assets/Scripts";
        /// <summary>
        /// The generation path for the enum.
        /// </summary>
        public static string CreationPath => $"{Directory.GetCurrentDirectory()}{CreationPathUserDefined}";

        /// <summary>
        /// Non-async file generator. Might cause crashes on bigger files.
        /// </summary>
        /// <returns>Generated file's information.</returns>
        public static FileInfo GenerateFile(string enumClassName, string[] enumClassValues = null, bool reloadAssets = true, DirectoryInfo directoryWrite = null)
        {
            StringBuilder FileText = new StringBuilder();

            FileText.Append("// Autogenerated by EnumGenerator.\n");
            FileText.Append($"public enum {enumClassName}\n");
            FileText.Append("{\n");
            if (enumClassValues == null)
            {
                // Generates a blank enum, goto statement is here from when i learnt c# lul
                // It's not terrible, using it as a 'panic' statement. (So it stays)
                FileText.Append("\n}");
                goto _DirSave;
            }

            /* Create the file contents */
            for (uint i = 0; i < enumClassValues.Length; i++)
            { enumClassValues[i] = enumClassValues[i].Replace(' ', '_'); }

            for (uint i = 0; i < enumClassValues.Length; i++)
            {
                /* 4 spaces behind the args. */
                FileText.Append($"    {enumClassValues[i]} = {i}{(i == enumClassValues.Length - 1 ? ' ' : ',')}\n");
            }
            FileText.Append("}");

        _DirSave:
            FileInfo inf;

            if (directoryWrite == null)
            {
                // Directory.GetCurrentDirectory() always returns visual studio project directory.

                if (!Directory.Exists(CreationPath))
                {
                    Debug.LogWarning($"Created a default directory for generated enum in : {CreationPath} | The file will look like : {CreationPath}/{enumClassName}.cs");
                    Directory.CreateDirectory(CreationPath);
                }

                using (var fs = File.Create($"{CreationPath}/{enumClassName}.cs"))
                {
                    string FTextString = FileText.ToString();
                    fs.Write(Encoding.UTF8.GetBytes(FTextString), 0, Encoding.UTF8.GetByteCount(FTextString));
                    inf = new FileInfo(fs.Name);
                }
            }
            else
            {
                if (!directoryWrite.Exists)
                {
                    Debug.LogWarning($"Created a default directory for generated enum in : {directoryWrite.FullName}");
                    directoryWrite.Create();
                }

                // NOTE : Enum file can exist in bxfw directory, which is not the default directory.
                // Search for files and delete the ones with the same name (avoid conflicts)
                foreach (var file in directoryWrite.GetFiles("*.cs", SearchOption.AllDirectories))
                {
                    // File exists with the same name, delete the file.
                    if (file.Name.Equals($"{enumClassName}.cs", StringComparison.InvariantCultureIgnoreCase))
                    {
                        // Backup the file with same name before deleting.
                        File.WriteAllBytes($"{file.FullName}.bak", File.ReadAllBytes(file.FullName));

                        File.Delete(file.FullName);
                    }
                }


                using (var fs = File.Create($"{directoryWrite.FullName}/{enumClassName}.cs"))
                {
                    string FTextString = FileText.ToString();

                    fs.Write(Encoding.UTF8.GetBytes(FTextString), 0, Encoding.UTF8.GetByteCount(FTextString));
                    inf = new FileInfo(fs.Name);
                }
            }

            if (reloadAssets)
            { AssetDatabase.Refresh(); }

            return inf;
        }
    }
}
#endif
/* Maybe the light probes?
[Serializable]
public class SphericalHarmonics
{
    public float[] Coefficients = new float[27];
}
*/

[Serializable]
public class LightmapScenarioData
{
    public string name;
    public Texture2D[] LightmapCompDir;
    public Texture2D[] LightmapCompLight;
    public Texture2D[] LightmapCompShadow;
    public Texture2D[] LightProbes;
    public LightmapsMode LightmapMode;

    public static void ApplyToLightmapOptions(LightmapScenarioData data)
    {
        int Length = LightmapSettings.lightmaps.Length;

        /* all you need is a list. (and not an array, please do not change it to an array) */
        List<LightmapData> LightMapDatArray = new List<LightmapData>();

        for (int i = 0; i < Length; i++)
        { LightMapDatArray.Add(new LightmapData { lightmapDir = data.LightmapCompDir[i], lightmapColor = data.LightmapCompLight[i], shadowMask = data.LightmapCompShadow[i] }); }

        LightmapSettings.lightmaps = LightMapDatArray.ToArray();

#if UNITY_EDITOR
        Debug.LogWarning("[ChangeLightmap] Applied lightmap options.");
        /* Completely Debug 
        for (int i = 0; i < Length; i++)
        { Debug.Log($"[ChangeLightmap] (Debug) More info about the current LightmapSettings (names) : {LightmapSettings.lightmaps[i].lightmapDir.name} | {LightmapSettings.lightmaps[i].shadowMask.name} | {LightmapSettings.lightmaps[i].lightmapColor.name} "); } */
#endif

        /* TODO : Change light probe assets if we can find where tf it is stored. */
    }
}

public class ChangeLightmap : MonoBehaviour
{
    public string LightmapName;

    public LightmapEnum DefaultLightmap;
    public bool SetDefaultLightmapOnAwake;

    /* Const & Hidden variables */
    private static readonly string ResFile = $"{Directory.GetCurrentDirectory()}/Assets/Resources/SavedLightmaps";
    public const string EnumName = "LightmapEnum";

    [HideInInspector] public List<LightmapScenarioData> LInfos = new List<LightmapScenarioData>();

    /* Runtime Methods. */
    private void Awake()
    {
        if (SetDefaultLightmapOnAwake && Enum.GetValues(typeof(LightmapEnum)).Length != 0)
        { SetLightmap(DefaultLightmap); }
    }

    public void SetLightmap(LightmapEnum option)
    { LightmapScenarioData.ApplyToLightmapOptions(LInfos[(int)option]); }

    /* Failed attempt at fading lMaps
     * Use a material and gather the textures for lightmap from there. In fact we can use a fully material based LightmapStorage
     * as we are just using c# (which is bad, use shaders instead).
    public void MakeFadeableLightmap(LightmapEnum to, float FadeSpeed, LightmapEnum from = (LightmapEnum)int.MinValue)
    {
        /* IgnoreFrom = Ignored if we want to not use a from value and use the current lightmap instead 
        // bool IgnoreFrom = (int)from == int.MinValue;

        /* Create faded lightmap textures. (we can bake or instance the textures) 
        StartCoroutine(CreateFadeImageRuntime((int)to, (int)from, FadeSpeed));

    }
    private IEnumerator CreateFadeImageRuntime(int To, int From, float FadeSpeed)
    {
        int Length = LightmapSettings.lightmaps.Length;

        LightmapData[][] dataFromto = new LightmapData[Length][];
        
        try
        {
            /* Gathering values 
            for (int i = 0; i < Length; i++)
            {
                dataFromto[i][0] = new LightmapData 
                { 
                    lightmapDir = LInfos[To].LightmapCompDir[i],
                    lightmapColor = LInfos[To].LightmapCompLight[i],
                    shadowMask = LInfos[To].LightmapCompShadow[i] 
                };
                dataFromto[i][1] = From != int.MinValue ? new LightmapData
                {
                    lightmapDir = LInfos[From].LightmapCompDir[i],
                    lightmapColor = LInfos[From].LightmapCompLight[i],
                    shadowMask = LInfos[From].LightmapCompShadow[i]
                }
                : LightmapSettings.lightmaps[i];
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"An exception occured while getting the lightmaps. Error Details\n{e.Message}\n{e.StackTrace}");
            yield break;
        }
        yield return null;

        /* Start a float fading. 
        CTween.To(() => { return secSubCoroutine[0]; }, (float f) => { secSubCoroutine[0] = f; }, 0f, FadeSpeed);
        CTween.To(() => { return secSubCoroutine[1]; }, (float f) => { secSubCoroutine[1] = f; }, 1f, FadeSpeed);

        /* Faded graphics 
        for (int i = 0; i < Length; i++)
        {
            for (int j = 0; j < dataFromto[i][0].lightmapColor.width * dataFromto[i][0].lightmapColor.height; j++)
            {
                /* It would be better if we made this on a material then get the shaders but idk. 
                 * In fact we have to enumerate through w * h amount of pixels. ok
                dataFromto[i][0].lightmapColor.SetPixels32
                    (0, 0, dataFromto[i][0].lightmapColor.width, dataFromto[i][0].lightmapColor.height,
                    new[] { new Color32(255, 255, 255, (byte)Mathf.Lerp(255, 0, secSubCoroutine[0])) });
                dataFromto[i][0].lightmapColor.SetPixels32
                    (0, 0, dataFromto[i][0].lightmapColor.width, dataFromto[i][0].lightmapColor.height,
                    new[] { new Color32(255, 255, 255, (byte)Mathf.Lerp(255, 0, secSubCoroutine[0])) });
                dataFromto[i][0].lightmapColor.SetPixels32
                    (0, 0, dataFromto[i][0].lightmapColor.width, dataFromto[i][0].lightmapColor.height,
                    new[] { new Color32(255, 255, 255, (byte)Mathf.Lerp(255, 0, secSubCoroutine[0])) });
            }
        }
    }
    /// <summary>
    /// Fade array for texture fading.
    /// 0 : Starts from 1
    /// 1 : Starts from 0
    /// </summary>
    private float[] secSubCoroutine = { 1f, 0f };
    */

    #region Unity Editor
#if UNITY_EDITOR

    #region Baking & Generation
    public LightmapScenarioData GenerateLightmapInfoFromDirectory(DirectoryInfo Dir)
    {
        /* Setup for files */
        var LightmapTexDir = new List<Texture2D>();
        var LightmapTexLight = new List<Texture2D>();
        var LightmapTexShadow = new List<Texture2D>();
        var ReflectProbe = new List<Texture2D>();
        var LmapMode = LightmapSettings.lightmapsMode;

        Debug.Log($"Started generation | Directory path : {Dir.FullName}, GetFiles result {Dir.GetFiles("*", SearchOption.AllDirectories).Length}");

        // Get the lightmap scenario data.
        foreach (FileInfo FInf in Dir.GetFiles("*", SearchOption.AllDirectories))
        {
            bool extIsPng = FInf.Extension == "*.png";
            bool extIsExr = FInf.Extension == "*.exr";

            if (!extIsPng && !extIsExr)
            {
                // Unsupported / Foreign file?
                Debug.Log($"[ChangeLightmap::GenerateLightmapInfoFromDirectory] File '{FInf.Name}' has unsupported extension, skipping.");
                continue;
            }

            string[] FInfSplitPath = FInf.FullName.Split('\\');
            /* 3 directories down for resources path for the file without the extension. */
            string ResPath = $"{FInfSplitPath[FInfSplitPath.Length - 3]}\\{FInfSplitPath[FInfSplitPath.Length - 2]}\\{FInfSplitPath[FInfSplitPath.Length - 1]}".Split('.')[0];

            /* Unity Generated Lightmap File Name Structure                     *
             * Lightmap Computed Dir : Lightmap-0_comp_dir.png                  *
             * Lightmap Computed Light : Lightmap-0_comp_light.exr              *
             * Lightmap Computed Shadowmask : Lightmap-0_comp_shadowmask.png    *
             * Lightmap Reflection Probe : ReflectionProbe-0.exr                */

            if (extIsPng)
            {
                if (FInf.Name.Contains("comp_dir"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains comp_dir.\nFile Info : {FInf.Name}");
                    LightmapTexDir.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }

                if (FInf.Name.Contains("comp_shadowmask"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains comp_shadowmask.\nFile Info : {FInf.Name}");
                    LightmapTexShadow.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }
            }

            if (extIsExr)
            {
                if (FInf.Name.Contains("comp_light"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains comp_light.\nFile Info : {FInf.Name}");
                    LightmapTexLight.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }

                if (FInf.Name.Contains("ReflectionProbe"))
                {
                    Debug.Log($"[ChangeLightmap] (Debug) File info name contains reflectionprobe.\nFile Info : {FInf.Name}");
                    ReflectProbe.Add(Resources.Load<Texture2D>(ResPath));
                    continue;
                }
            }
        }

        // Create the data.
        var sData = new LightmapScenarioData
        {
            name = LightmapName,
            LightmapCompDir = LightmapTexDir.ToArray(),
            LightmapCompLight = LightmapTexLight.ToArray(),
            LightmapCompShadow = LightmapTexShadow.ToArray(),
            LightProbes = ReflectProbe.ToArray(),
            LightmapMode = LmapMode
        };

        //LightmapInfos.Add(sData);
        // GenerateJSONSaveFolder(sData, $"{Dir.FullName}\\{JsonFileName}");

        Debug.Log("[ChangeLightmap] Succesfully generated LightmapScenarioData.");

        return sData;
    }

    /// <summary>
    /// Clears file and regenerates the <see cref="LightmapEnum"/>.
    /// </summary>
    /// <param name="deleteFolder">Should the folder of generated lightmaps be deleted?</param>
    public void ClearData(bool deleteFolder)
    {
        if (deleteFolder)
        {
            Directory.Delete(ResFile);
            File.Delete($"{ResFile}.meta");
            LInfos.Clear();
            EnumGenerator.GenerateFile(EnumName);
        }
        else
        {
            LInfos.Clear();
            EnumGenerator.GenerateFile(EnumName);
        }
    }

    /// <summary>
    /// Bakes & creates a new lightmap.
    /// </summary>
    /// <param name="optionalEndActionToAdd"></param>
    public void BakeLightmapInstance(Action optionalEndActionToAdd = null)
    {
        if (Application.isPlaying)
        {
            Debug.LogWarning("[ChangeLightmap] You cannot bake lights while in play mode!");
            return;
        }

        // Gather the names of the enum.
        var EnumArr = Enum.GetValues(typeof(LightmapEnum));
        string[] DataAssetNames = new string[0];
        if (EnumArr.Length != 0)
        {
            Array.Resize(ref DataAssetNames, EnumArr.Length + 1);

            for (int i = 0; i < EnumArr.Length; i++)
                DataAssetNames[i] = ((LightmapEnum)EnumArr.GetValue(i)).ToString();

            DataAssetNames[EnumArr.Length - 1] = LightmapName;
        }

        // Start baking.
        if (Lightmapping.BakeAsync())
        {
            Debug.Log("[ChangeLightmap] Bake with copy has started...");

            /* Questions about the Lightmapping.bakeCompleted event delegate *
             * 1 : How tf you add the same event over and over?              *
             * 1A : It cleans itself. (only we can hope it does that)        *
             * 2 : What happens when the bake is postponed or cancelled?     *
             * 2A : It doesn't execute.                                      *
             * thank for not asking -> me looking for who asked              */

            Lightmapping.bakeCompleted += () =>
            {
                /* Find the Lightmapping directory, then put it into resources
                 * We can use the lightmapper file from resources. */
                try
                {
                    Additionals.DirectoryCopy(GetLightmapDataDirectory().FullName, $"{ResFile}\\{LightmapName}", true);
                    LInfos.Add(GenerateLightmapInfoFromDirectory(new DirectoryInfo($"{ResFile}\\{LightmapName}")));
                }
                catch (Exception e)
                {
                    Debug.LogError($"[ChangeLightmap] An exception occured while loading resource.\nException : {e.Message}\nStacktrace : {e.StackTrace}");
                    return;
                }

                EnumGenerator.GenerateFile(EnumName, DataAssetNames);
            };

            if (optionalEndActionToAdd != null)
            { Lightmapping.bakeCompleted += optionalEndActionToAdd; }
        }
    }
    /// <summary>
    /// Adds directory to the baked assets list.
    /// The name of the lightmap the same as the directory name.
    /// </summary>
    public void AddToBakedList(DirectoryInfo inf, bool UseUserdefStr)
    {
        /* Find the Lightmapping directory, then put it into resources
         * We can use the lightmapper file from resources. */
        if (Application.isPlaying)
        {
            Debug.LogError("[ChangeLightmap] You cannot save baked lights while in play mode!");
            return;
        }

        /* Cast the enum values into strings
         * We store the Enum names in (you guessed it) the Enum itself. */
        var EnumArr = Enum.GetValues(typeof(LightmapEnum));
        List<string> DataAssetNames = new List<string>();

        if (EnumArr.Length != 0)
        {
            for (int i = 0; i < EnumArr.Length; i++)
            { DataAssetNames.Add(((LightmapEnum)EnumArr.GetValue(i)).ToString()); }
        }

        DataAssetNames.Add(UseUserdefStr ? LightmapName : inf.Name);

        /* DirectoryInfo copiedLightmap = new DirectoryInfo(GetLightmapperDirectory().FullName); */
        Additionals.DirectoryCopy(inf.FullName, $"{ResFile}\\{(UseUserdefStr ? LightmapName : inf.Name)}", true);

        try
        {
            /* Add the generated info to array.
             * oh god why do i use stupid string consts, i need to clean this. but it works B) */
            LInfos.Add(GenerateLightmapInfoFromDirectory(new DirectoryInfo($"{ResFile}\\{(UseUserdefStr ? LightmapName : inf.Name)}")));
        }
        catch (Exception e)
        {
            Debug.LogError($"[ChangeLightmap] An exception occured while loading resource.\nException : {e.Message}\nStacktrace : {e.StackTrace}");
            return;
        }

        EnumGenerator.GenerateFile(EnumName, DataAssetNames.ToArray());
    }
    #endregion

    #region Directory Actions
    /* oh no this is terrible. */
    #region Lightmapper Directory
    /// <summary>
    /// Gets the current lightmapper directory for current scene.
    /// </summary>
    /// <returns></returns>
    //public static DirectoryInfo GetLightmapperDirectory()
    //{
    //    string[] unityFiles = Directory.GetFiles($"{Directory.GetCurrentDirectory()}\\Assets", "*.unity", SearchOption.AllDirectories);

    //    string currSceneName = SceneManager.GetActiveScene().name;

    //    foreach (string s in unityFiles)
    //    {
    //        string[] split = s.Split('\\');

    //        if (split[split.Length - 1].Split('.')[0].Equals(currSceneName))
    //        {
    //            return new DirectoryInfo(s.Split('.')[0]);
    //        }
    //    }

    //    Debug.LogError("Could not find any lightmapper directory.");
    //    return null;
    //}
    /// <summary>
    /// Gets the current lightmapper directory for the written scene name.
    /// </summary>
    /// <param name="SceneName"></param>
    /// <returns></returns>
    public static DirectoryInfo GetLightmapDataDirectory(string SceneName = null)
    {
        string[] unityFiles = Directory.GetFiles($"{Directory.GetCurrentDirectory()}\\Assets", "*.unity", SearchOption.AllDirectories);

        string currSceneName = null;

        for (int i = 0; i < SceneManager.sceneCount; i++)
        {
            string s = SceneManager.GetSceneAt(i).name;
            if (SceneName.Equals(s))
            {
                currSceneName = s;
                break;
            }
        }

        if (string.IsNullOrEmpty(currSceneName))
        {

            currSceneName = SceneManager.GetActiveScene().name;
        }

        foreach (string s in unityFiles)
        {
            string[] dirSeperated = s.Split('\\');
            var sceneLMapDirName = dirSeperated[dirSeperated.Length - 1].Split('.')[0];

            if (sceneLMapDirName.Equals(currSceneName))
            {
                var sceneLMapDir = s.Split('.')[0];

                if (!Directory.Exists(sceneLMapDir))
                {
                    Debug.LogError($"[GetLightmapDataDirectory] No lightmaps was generated for the scene : '{SceneName}'. Please generate lightmaps.");
                    return null;
                }

                /* Found the scene directory, 
                 * find the directory nearby the Scene file and copy that to your destination. */
                return new DirectoryInfo(s.Split('.')[0]);
            }
        }

        Debug.LogError("[GetLightmapDataDirectory] Could not find any lightmap data directory.");
        return null;
    }
    public static DirectoryInfo GetLightmapperDirectory(int SceneIndex)
    {
        string[] unityFiles = Directory.GetFiles($"{Directory.GetCurrentDirectory()}\\Assets", "*.unity", SearchOption.AllDirectories);

        string SceneNameToMatch = SceneManager.GetSceneAt(SceneIndex).name;

        if (string.IsNullOrEmpty(SceneNameToMatch))
        {
            Debug.LogError($"No scene with index {SceneIndex} exists.");
            return null;
        }

        foreach (string s in unityFiles)
        {
            string[] split = s.Split('\\');

            /* welcome to mess
             * you don't need regex, you have a hakkerman */
            if (split[split.Length - 1].Split('.')[0].Equals(SceneNameToMatch))
            {
                /* Found the scene directory, 
                 * find the directory nearby the Scene file and copy that to your destination. */
                return new DirectoryInfo(s.Split('.')[0]);
            }
        }

        Debug.LogError("Could not find any lightmapper directory.");
        return null;
    }
    #endregion

    #endregion

#endif
    #endregion
}
