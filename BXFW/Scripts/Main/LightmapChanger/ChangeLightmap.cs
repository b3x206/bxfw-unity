#if UNITY_EDITOR
using UnityEditor;
using BXFW.Tools.Editor;
#endif

using UnityEngine;
using UnityEngine.SceneManagement;

using System;
using System.Text;
using System.IO;
using System.Collections.Generic;

#if UNITY_EDITOR
namespace BXFW.Tools.Editor
{
    /// <summary>
    /// Enum generator. Only meant for use in editor.
    /// </summary>
    public static class EnumGenerator
    {
        /// <summary>
        /// User defined creation path.
        /// <br>This is stored as another value for appending it with <see cref="Directory.GetCurrentDirectory"/>.</br>
        /// </summary>
        public static string CreationPathUserDefined = "/Assets/Scripts";
        /// <summary>
        /// The generation path for the enum.
        /// </summary>
        public static string CreationPath => string.Format("{0}{1}", Directory.GetCurrentDirectory(), CreationPathUserDefined);

        /// <summary>
        /// Non-async file generator. Might cause crashes on bigger files.
        /// </summary>
        /// <returns>Generated file's information.</returns>
        public static FileInfo GenerateFile(string enumClassName, string[] enumClassValues = null, bool reloadAssets = true, DirectoryInfo directoryWrite = null)
        {
            StringBuilder FileText = new StringBuilder();

            FileText.Append("// Autogenerated by EnumGenerator.\n");
            FileText.Append(string.Format("public enum {0}\n", enumClassName));
            FileText.Append("{\n");
            if (enumClassValues == null)
            {
                // Generates a blank enum
                // About goto : It's not terrible, using it as a 'panic' statement. (So it stays)
                FileText.Append("\n}");
                goto _DirSave;
            }

            // Create the file contents
            for (uint i = 0; i < enumClassValues.Length; i++)
            { enumClassValues[i] = enumClassValues[i].Replace(' ', '_'); }

            for (uint i = 0; i < enumClassValues.Length; i++)
            {
                // 4 spaces behind the args.
                FileText.Append(string.Format("    {0} = {1}{2}\n", enumClassValues[i], i, i == enumClassValues.Length - 1 ? ' ' : ','));
            }
            FileText.Append("}");

        _DirSave:
            FileInfo inf;

            if (directoryWrite == null)
            {
                // Directory.GetCurrentDirectory() always returns visual studio project directory.
                if (!Directory.Exists(CreationPath))
                {
                    Debug.LogWarning(string.Format("Created a default directory for generated enum in : {0} | The file will be : {0}/{1}.cs", CreationPath, enumClassName));
                    Directory.CreateDirectory(CreationPath);
                }

                using (var fs = File.Create(string.Format("{0}/{1}.cs", CreationPath, enumClassName)))
                {
                    string FTextString = FileText.ToString();
                    fs.Write(Encoding.UTF8.GetBytes(FTextString), 0, Encoding.UTF8.GetByteCount(FTextString));
                    inf = new FileInfo(fs.Name);
                }
            }
            else
            {
                if (!directoryWrite.Exists)
                {
                    Debug.LogWarning(string.Format("[EnumGenerator] Created a default directory for generated enum in : '{0}'.", directoryWrite.FullName));
                    directoryWrite.Create();
                }

                // NOTE : Enum file can exist in bxfw directory, which is not the default directory.
                // Search for files and delete the ones with the same name (avoid conflicts)
                foreach (var file in directoryWrite.GetFiles("*.cs", SearchOption.AllDirectories))
                {
                    // File exists with the same name, delete the file.
                    if (file.Name.Equals(string.Format("{0}.cs", enumClassName), StringComparison.InvariantCultureIgnoreCase))
                    {
                        // Backup the file with same name before deleting.
                        File.WriteAllBytes(string.Format("{0}.cs", file.FullName), File.ReadAllBytes(file.FullName));

                        File.Delete(file.FullName);
                    }
                }


                using (var fs = File.Create(string.Format("{0}/{1}.cs", directoryWrite.FullName, enumClassName)))
                {
                    string FTextString = FileText.ToString();

                    fs.Write(Encoding.UTF8.GetBytes(FTextString), 0, Encoding.UTF8.GetByteCount(FTextString));
                    inf = new FileInfo(fs.Name);
                }
            }

            if (reloadAssets)
            { AssetDatabase.Refresh(); }

            return inf;
        }
    }
}
#endif

// TODO : Use string array with dropdown resource (basically use the monobehaviour or a scriptable object) instead of 'LightmapEnum'
// That was a bad idea.
namespace BXFW
{
    /// <summary>
    /// Scene data for the baked lightmap.
    /// </summary>
    [Serializable]
    public class LightmapScenarioData
    {
        public string name;
        public Texture2D[] LightmapCompDir;
        public Texture2D[] LightmapCompLight;
        public Texture2D[] LightmapCompShadow;
        public Texture2D[] LightProbes;
        public LightmapsMode LightmapMode;
        //[Serializable]
        //public class SphericalHarmonics
        //{
        //    public float[] Coefficients = new float[27];
        //}
        //public SphericalHarmonics LightmapReflectProbesCF;

        public static void ApplyToLightmapOptions(LightmapScenarioData data)
        {
            int Length = LightmapSettings.lightmaps.Length;

            List<LightmapData> LightMapDatArray = new List<LightmapData>();

            for (int i = 0; i < Length; i++)
            { LightMapDatArray.Add(new LightmapData { lightmapDir = data.LightmapCompDir[i], lightmapColor = data.LightmapCompLight[i], shadowMask = data.LightmapCompShadow[i] }); }

            LightmapSettings.lightmaps = LightMapDatArray.ToArray();

#if UNITY_EDITOR
            Debug.LogWarning("[ChangeLightmap::ApplyToLightmapOptions] Applied lightmap options.");
#endif
            // TODO : Change light probe assets if we can find where the hell it is stored.
        }
    }

    /// <summary>
    /// Change lightmap using this class on anywhere in the scene.
    /// </summary>
    public class ChangeLightmap : MonoBehaviour
    {
        public string LightmapName;

        public int DefaultLightmap;
        public bool SetDefaultLightmapOnAwake;

        // Const & Hidden variables.
        private static readonly string ResFile = string.Format("{0}/Assets/Resources/SavedLightmaps", Directory.GetCurrentDirectory());
        public const string EnumName = "LightmapEnum";

        [HideInInspector] public List<LightmapScenarioData> LInfos = new List<LightmapScenarioData>();

        // Runtime methods (without the editor stuff)
        private void Awake()
        {
            if (SetDefaultLightmapOnAwake/* && Enum.GetValues(typeof(LightmapEnum)).Length != 0*/)
            { SetLightmap(DefaultLightmap); }
        }

        public void SetLightmap(int option)
        { LightmapScenarioData.ApplyToLightmapOptions(LInfos[(int)option]); }

        #region Unity Editor
#if UNITY_EDITOR

#if UNITY_EDITOR_WIN
        private const char filePathSeperatorChar = '\\';
#else
        private const char filePathSeperatorChar = '/';
#endif

        #region Baking & Generation
        public LightmapScenarioData GenerateLightmapInfoFromDirectory(DirectoryInfo Dir)
        {
            // Setup for files.
            var LightmapTexDir = new List<Texture2D>();
            var LightmapTexLight = new List<Texture2D>();
            var LightmapTexShadow = new List<Texture2D>();
            var ReflectProbe = new List<Texture2D>();
            var LmapMode = LightmapSettings.lightmapsMode;

            Debug.Log(string.Format("[ChangeLightmap] Started generation | Directory path : {0}, GetFiles.Length={1}", Dir.FullName, Dir.GetFiles("*", SearchOption.AllDirectories).Length));

            // Get the lightmap scenario data.
            foreach (FileInfo FInf in Dir.GetFiles("*", SearchOption.AllDirectories))
            {
                bool extIsPng = FInf.Extension == "*.png";
                bool extIsExr = FInf.Extension == "*.exr";

                if (!extIsPng && !extIsExr)
                {
                    // Unsupported / Foreign file?
                    Debug.Log(string.Format("[ChangeLightmap::GenerateLightmapInfoFromDirectory] File '{0}' has unsupported extension, skipping.", FInf.Name));
                    continue;
                }

                // Asset info split properly. (Basically 'ResPath')
                string ResPath = FInf.FullName.Substring(
                    FInf.FullName.IndexOf(string.Format("{0}{1}Assets", Directory.GetCurrentDirectory(), filePathSeperatorChar)) + 1).Split('.')[0];

                /* Unity Generated Lightmap File Name Structure                     *
                 * Lightmap Computed Dir : Lightmap-0_comp_dir.png                  *
                 * Lightmap Computed Light : Lightmap-0_comp_light.exr              *
                 * Lightmap Computed Shadowmask : Lightmap-0_comp_shadowmask.png    *
                 * Lightmap Reflection Probe : ReflectionProbe-0.exr                */

                // Bad method of detecting type of file, but unity doesn't have a lightmap api other than 'Bake' (?)
                if (extIsPng)
                {
                    if (FInf.Name.Contains("comp_dir"))
                    {
                        LightmapTexDir.Add(Resources.Load<Texture2D>(ResPath));
                        continue;
                    }

                    if (FInf.Name.Contains("comp_shadowmask"))
                    {
                        LightmapTexShadow.Add(Resources.Load<Texture2D>(ResPath));
                        continue;
                    }
                }

                if (extIsExr)
                {
                    if (FInf.Name.Contains("comp_light"))
                    {
                        LightmapTexLight.Add(Resources.Load<Texture2D>(ResPath));
                        continue;
                    }

                    if (FInf.Name.Contains("ReflectionProbe"))
                    {
                        ReflectProbe.Add(Resources.Load<Texture2D>(ResPath));
                        continue;
                    }
                }
            }

            // Create the data.
            var sData = new LightmapScenarioData
            {
                name = LightmapName,
                LightmapCompDir = LightmapTexDir.ToArray(),
                LightmapCompLight = LightmapTexLight.ToArray(),
                LightmapCompShadow = LightmapTexShadow.ToArray(),
                LightProbes = ReflectProbe.ToArray(),
                LightmapMode = LmapMode
            };

            Debug.Log("[ChangeLightmap] Succesfully generated LightmapScenarioData.");

            return sData;
        }

        /// <summary>
        /// Clears file and regenerates the <see cref="LightmapEnum"/>.
        /// </summary>
        /// <param name="deleteFolder">Should the folder of generated lightmaps be deleted?</param>
        public void ClearData(bool deleteFolder)
        {
            if (deleteFolder)
            {
                Directory.Delete(ResFile);
                File.Delete(string.Format("{0}.meta", ResFile));
                LInfos.Clear();
                EnumGenerator.GenerateFile(EnumName);
            }
            else
            {
                LInfos.Clear();
                EnumGenerator.GenerateFile(EnumName);
            }
        }

        /// <summary>
        /// Bakes & creates a new lightmap.
        /// </summary>
        /// <param name="optionalEndActionToAdd"></param>
        public void BakeLightmapInstance(Action optionalEndActionToAdd = null)
        {
            if (Application.isPlaying)
            {
                Debug.LogWarning("[ChangeLightmap] You cannot bake lights while in play mode!");
                return;
            }

            // Gather the names of the enum.
            var EnumArr = new int[1]/*Enum.GetValues(typeof(LightmapEnum))*/;
            string[] DataAssetNames = new string[0];
            if (EnumArr.Length != 0)
            {
                Array.Resize(ref DataAssetNames, EnumArr.Length + 1);

                for (int i = 0; i < EnumArr.Length; i++)
                    DataAssetNames[i] = EnumArr[i].ToString();

                DataAssetNames[EnumArr.Length - 1] = LightmapName;
            }

            // Start baking.
            if (Lightmapping.BakeAsync())
            {
                Debug.Log("[ChangeLightmap] Bake with copy has started...");

                /* Questions about the Lightmapping.bakeCompleted event delegate *
                 * 1 : How tf you add the same event over and over?              *
                 * 1A : It cleans itself. (only we can hope it does that)        *
                 * 2 : What happens when the bake is postponed or cancelled?     *
                 * 2A : It doesn't execute.                                      *
                 * thank for not asking -> me looking for who asked              */

                Lightmapping.bakeCompleted += () =>
                {
                /* Find the Lightmapping directory, then put it into resources
                 * We can use the lightmapper file from resources. */

                    try
                    {
                        BXFW.Additionals.DirectoryCopy(GetLightmapDataDirectory().FullName, string.Format("{0}{1}{2}", ResFile, filePathSeperatorChar, LightmapName), true);
                        LInfos.Add(GenerateLightmapInfoFromDirectory(new DirectoryInfo(string.Format("{0}{1}{2}", ResFile, filePathSeperatorChar, LightmapName))));
                    }
                    catch (Exception e)
                    {
                        Debug.LogError(string.Format("[ChangeLightmap] An exception occured while loading resource.\nException : {0}\nStacktrace : {1}", e.Message, e.StackTrace));
                        return;
                    }

                    EnumGenerator.GenerateFile(EnumName, DataAssetNames);
                };

                if (optionalEndActionToAdd != null)
                { Lightmapping.bakeCompleted += optionalEndActionToAdd; }
            }
        }
        /// <summary>
        /// Adds directory to the baked assets list.
        /// The name of the lightmap the same as the directory name.
        /// </summary>
        public void AddToBakedList(DirectoryInfo inf, bool UseUserdefStr)
        {
            /* Find the Lightmapping directory, then put it into resources
             * We can use the lightmapper file from resources. */
            if (Application.isPlaying)
            {
                Debug.LogError("[ChangeLightmap] You cannot save baked lights while in play mode!");
                return;
            }

            /* Cast the enum values into strings
             * We store the Enum names in (you guessed it) the Enum itself. */
            var EnumArr = new int[1]/*Enum.GetValues(typeof(LightmapEnum))*/;
            List<string> DataAssetNames = new List<string>();

            if (EnumArr.Length != 0)
            {
                for (int i = 0; i < EnumArr.Length; i++)
                { DataAssetNames.Add(EnumArr[i].ToString()); }
            }

            DataAssetNames.Add(UseUserdefStr ? LightmapName : inf.Name);

            Additionals.DirectoryCopy(inf.FullName, string.Format("{0}{1}{2}", ResFile, filePathSeperatorChar, UseUserdefStr ? LightmapName : inf.Name), true);

            try
            {
                LInfos.Add(GenerateLightmapInfoFromDirectory(new DirectoryInfo(string.Format("{0}{1}{2}", ResFile, filePathSeperatorChar, UseUserdefStr ? LightmapName : inf.Name))));
            }
            catch (Exception e)
            {
                Debug.LogError(string.Format("[ChangeLightmap] An exception occured while loading resource.\nException : {0}\nStacktrace : {1}", e.Message, e.StackTrace));
                return;
            }

            EnumGenerator.GenerateFile(EnumName, DataAssetNames.ToArray());
        }
        #endregion

        #region Directory Actions
        /// <summary>
        /// Gets the current lightmapper directory for the scene with name <paramref name="SceneName"/>.
        /// </summary>
        public static DirectoryInfo GetLightmapDataDirectory(string SceneName = null)
        {
            // Find file.
            string[] unityFiles = Directory.GetFiles(string.Format("{0}{1}Assets", Directory.GetCurrentDirectory(), filePathSeperatorChar), "*.unity", SearchOption.AllDirectories);
            string currSceneName = null;

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                string s = SceneManager.GetSceneAt(i).name;
                if (SceneName.Equals(s))
                {
                    currSceneName = s;
                    break;
                }
            }

            if (string.IsNullOrEmpty(currSceneName))
            {
                currSceneName = SceneManager.GetActiveScene().name;
            }

            foreach (string s in unityFiles)
            {
                string[] dirSeperated = s.Split('\\');
                var sceneLMapDirName = dirSeperated[dirSeperated.Length - 1].Split('.')[0];

                if (sceneLMapDirName.Equals(currSceneName))
                {
                    var sceneLMapDir = s.Split('.')[0];

                    if (!Directory.Exists(sceneLMapDir))
                    {
                        Debug.LogError(string.Format("[GetLightmapDataDirectory] No lightmaps was generated for the scene : '{0}'. Please generate lightmaps.", SceneName));
                        return null;
                    }

                    /* Found the scene directory, 
                     * find the directory nearby the Scene file and copy that to your destination. */
                    return new DirectoryInfo(s.Split('.')[0]);
                }
            }

            Debug.LogError("[GetLightmapDataDirectory] Could not find any lightmap data directory.");
            return null;
        }
        /// <summary>
        /// Gets the current lightmapper directory for the scene with index <paramref name="SceneIndex"/>.
        /// </summary>
        public static DirectoryInfo GetLightmapperDirectory(int SceneIndex)
        {
            var sceneWithIndex = SceneManager.GetSceneByBuildIndex(SceneIndex);

            if (sceneWithIndex == null)
            {
                Debug.LogError(string.Format("[GetLightmapDataDirectory] No scene was found with index : '{0}'. Please assign the scene index.", SceneIndex));
                return null;
            }

            // Use the string based find as we are getting directories.
            return GetLightmapDataDirectory(sceneWithIndex.name);
        }
        #endregion
#endif
        #endregion
    }
}